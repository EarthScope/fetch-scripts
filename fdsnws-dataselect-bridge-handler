#!/usr/bin/perl
#
# fdsnws-dataselect "bridge" handler:
#
# A test and template handler for the IRIS Web Service Shell (WSS)
# implementing fdsnws-dataselect version 1.1.
#
# This handler validates and processes a request and responds as
# expected by the WSS using a IRIS web service to fulfill the request.
#
# Data requests are submitted either as command line arguments or via
# stdin.  All returned data is written to STDOUT and all diagnostics
# and errors are written to STDERR.
#
## Use as a template
#
# To modify this handler to access local data center repositories the
# HandleRequest() routine should be modified, replacing the call to a
# IRIS web service with data extraction from local repositories or
# whatever else might be appropriate.
#
#
# The exit statuses employed and expected by the WSS:
#
# Exit Status = Description
# 0  =  Successfully processed request, data returned via stdout
# 1  =  General error. An error description may be provided on stderr
# 2  =  No data. Request was successful but results in no data
# 3  =  Invalid or unsupported argument/parameter
# 4  =  Too much data requested
#
# Input selections can be specified in these ways:
#
# 1) Command line arguments: --network, --station, --location, --channel,
#      --quality, --starttime, --endtime
#
# 2) A "selection" from a file or STDIN (when the --STDIN option is set).
#    The format of the selection is as is expected for fdsnws-dataselect:
# -------------------
#  quality=M
#  minimumlength=0.0
#  longestonly=FALSE
#  NET STA LOC CHA STARTTIME ENDTIME
#  NET STA LOC CHA STARTTIME ENDTIME
#  NET STA LOC CHA STARTTIME ENDTIME
#  ...
# -------------------
#
# Name parameter lists: each of network, station, location and channel
# may contain a list of comma separated values, which may further
# contain wildcards.  For example, the channel value may contain
# "LHE,LHN,LHZ" or "LH?,BH?".
#
# All start times and end times are assumed to be in UTC and expected
# in be one of these forms (with optional trailing Z):
#   YYYY-MM-DD[T ]HH:MM:SS.ssssss
#   YYYY-MM-DD[T ]HH:MM:SS
#   YYYY-MM-DD
#
# As a bridge to another service, this handler cannot be used for
# authenticted access, because the handler does not know the password
# submitted to the service and, thus, cannot submit the credentials to
# the backend service.
#
#
# ChangeLog:
#
# 2014.189:
#  - Allow 'mseed' as a valid value for format in addition to 'miniseed'.
#
# 2014.168:
#  - Add handling for fdsnws-dataselect 1.1 'format' parameter by accepting
#  the --format option and forwarding the parameter.
#
# 2013.042:
#  - Call UserAgent::env_proxy so that LWP requests use common
#  environtment variables such as http_proxy.
#
# 2013.031:
#  - Initial version

use strict;
use Getopt::Long;
use File::Basename;
use Config;
use LWP::UserAgent;
use HTTP::Status qw(status_message);
use HTTP::Date;

my $version  = "2014.189";

my $scriptname = basename($0);

my $verbose  = undef;
my $usage    = undef;
my $pretend  = undef;

my $selectfile = undef;
my $selectstdin = undef;

my $username = undef;
my $longestonly  = undef;
my $minimumlength  = undef;
my $format    = undef;
my $network   = undef;
my $station   = undef;
my $location  = undef;
my $channel   = undef;
my $quality   = undef;
my $starttime = undef;
my $endtime   = undef;
my @requests  = ();


# The WSS will always translate URI parameters to command line options
# prefixed with a double-dash (--), e.g. 'station=ANMO' becomes '--station ANMO'
#
# This characteristic is leveraged to allow this handler script to
# support options specified with a single dash (for diagnostics and
# testing) that can never be specified by a remote call via the WSS.
#
# This is enforced by limiting the arguments that can be called
# using double-dashes to a subset needed to match the web service
# request paramters and the special case '--STDIN' and '--username'
# options.  All such options should be in the @doubledash list.

my @doubledash = ('STDIN', 'username', 'minimumlength','longestonly',
		  'network', 'net', 'station', 'sta',
		  'location', 'loc', 'channel', 'cha',
		  'starttime', 'start', 'endtime', 'end',
		  'quality', 'format');

foreach my $idx ( 0..$#ARGV ) {
  if ( $ARGV[$idx] =~ /^--.+/ )  {
    my $arg = substr $ARGV[$idx], 2;

    if ( ! grep (/^${arg}$/, @doubledash) ) {
      print STDERR "Unrecognized option: $ARGV[$idx]\n";
      exit (3);
    }
  }
}

# Parse command line arguments
Getopt::Long::Configure (qw{ bundling_override no_auto_abbrev no_ignore_case_always });
my $getoptsret = GetOptions ( 'v+'           => \$verbose,
                              'h'            => \$usage,
                              'p'            => \$pretend,

                              's=s'          => \$selectfile,
                              'STDIN'        => \$selectstdin,

                              'username=s'   => \$username,
                              'longestonly=s' => \$longestonly,
                              'minimumlength=s' => \$minimumlength,
                              'format=s'         => \$format,
                              'network|net|N=s'  => \$network,
                              'station|sta|S=s'  => \$station,
                              'location|loc|L=s' => \$location,
                              'channel|cha|C=s'  => \$channel,
                              'quality|Q=s'      => \$quality,
                              'starttime|start|ts=s' => \$starttime,
                              'endtime|end|te=s' => \$endtime,
                              );

exit (3) if ( ! $getoptsret );

if ( defined $usage )
  {
    my $name = basename ($0);
    print STDERR "WSS Handler to fetch waveform data from the IRIS DMC ($version)\n\n";
    print STDERR "Usage: $name [-v] \n\n";
    print STDERR " -h           Print this help message\n";
    print STDERR " -v           Be more verbose, multiple flags can be used\n";
    print STDERR " -p           Pretend, do everything except request data from backend\n";
    print STDERR "\n";
    print STDERR " -s selectfile Determine extraction from a selection file\n";
    print STDERR " --STDIN       Selection will be supplied via stdin\n";
    print STDERR "\n";
    print STDERR " --network    Network code, list and wildcards (* and ?) accepted\n";
    print STDERR " --station    Station code, list and wildcards (* and ?) accepted\n";
    print STDERR " --location   Location ID, list and wildcards (* and ?) accepted\n";
    print STDERR " --channel    Channel codes, list and wildcards (* and ?) accepted\n";
    print STDERR " --quality    Quality ID selection, default is 'M' for best data\n";
    print STDERR " --starttime  Specify start time (YYYY-MM-DDTHH:MM:SS.ssssss)\n";
    print STDERR " --endtime    Specify end time (YYYY-MM-DDTHH:MM:SS.ssssss)\n";
    print STDERR " --longestonly TRUE|FALSE   Limit to longest segment only\n";
    print STDERR " --minimumlength secs    Enforce minimum segment length in seconds\n";
    print STDERR " --format format   Specify result format (e.g. miniseed)\n";
    print STDERR "\n";

    exit (1);
}

# Track run duration for diagnostics
my $startrequest = time;

# Populate global request parameters from input selection, exit if needed
my $retval = &ReadRequest();

if ( $retval ) {
  exit ($retval);
}

# Check for empty requests
if ( ! @requests ) {
  print STDERR "No data selection specified\n";
  exit (3);
}

# Validate global request parameters, exit if needed
my $retval = &ValidateRequest();

if ( $retval ) {
  exit ($retval);
}

# Handle/fullfill data request
my $retval = &HandleRequest();

if ( $retval ) {
  exit ($retval);
}

if ( $verbose ) {
  my $runtime = time - $startrequest;
  print STDERR "Finished ($runtime seconds)\n";
}

# Return with success code
exit (0);

## End of main


######################################################################
# HandleRequest:
#
# Process validated request and return selected data on STDOUT.  On
# errors this routine should return either an appropriate error code
# or exit within the routine with the appropriate message and error
# code.  The request parameters are available from these global
# variables:
#
#  $quality       : An optional single character request quality (or wildcard)
#  $minimumlength : An optional value for minimum segment length (seconds)
#  $longestonly   : A boolean value to request longest segment only (TRUE or FALSE)
#  @requests      : A list of request lines as in the following format:
#                    "Net Sta Loc Chan Starttime Endtime"
#
# Name parameter lists in the @request entries: each of Net, Sta, Loc
# and Chan may contain a list of comma separated values, which may
# futher contain wildcards.  For example, the channel value may
# contain "LHE,LHN,LHZ" or "LH?,BH?".
#
# When a fatal error is reached in this routine be sure to use the
# appropriate exit code:
#
#   Exit Status = Description
#   1  =  General error. An error description may be provided on stderr
#   2  =  No data. Request was successful but results in no data
#   3  =  Invalid or unsupported argument/parameter
#   4  =  Too much data requested
#
# Returns 0 on success, otherwise an appropriate exit code.
######################################################################
sub HandleRequest ()
{
  # Web service to process data request, this the other end of the bridge
  #my $backendservice = 'http://service.iris.edu/fdsnwsbeta/dataselect/1';
  my $backendservice = 'http://service.iris.edu/fdsnws/dataselect/1';

  # HTTP UserAgent reported to web services
  my $useragent = "$scriptname/$version Perl/$] " . new LWP::UserAgent->_agent;

  # In this bridge handler authentication cannot be supported
  if ( $username ) {
    print STDERR "Handler does not support authenticated data access\n";
    return 1;
  }

  # Create the data request POST body
  my $requestpost = "";
  $requestpost .= "quality=$quality\n" if ($quality );
  $requestpost .= "minimumlength=$minimumlength\n" if ( $minimumlength );
  $requestpost .= "longestonly=$longestonly\n" if ( $longestonly );
  $requestpost .= "format=$format\n" if ( $format );

  # Loop through data request lines and add to POST body (splitting for illustration)
  foreach my $req ( @requests ) {
    my ($net,$sta,$loc,$chan,$start,$end) = split (' ', $req);

    $requestpost .= "$net $sta $loc $chan $start $end\n";
  }

  if ( $verbose >= 3 ) {
    print STDERR "Backend POST\n";
    print STDERR "-----------\n";
    print STDERR "${requestpost}";
    print STDERR "-----------\n";
  }

  # Stop here if pretending
  return 0 if $pretend;

  # Create HTTP client, submit POST request to backend service and
  # write returned content to STDOUT using a callback function.
  my $ua = LWP::UserAgent->new();
  $ua->agent($useragent);
  $ua->env_proxy;
  my $response = $ua->post ("${backendservice}/query",
			    Content => $requestpost,
			    ':content_cb' => \&DLCallBack);

  # Translate backend service response codes to expected exit status with messages
  my $respcode = $response->code;
  if ( $respcode == 204 ) {
    return 2;
  }
  elsif ( $respcode == 413 ) {
    print STDERR "Too much data requested\n";
    return 4;
  }
  elsif ( $respcode >= 400 && $respcode < 500 ) {
    print STDERR "Error with arguments: %s\n", $response->decoded_content();
    return 3;
  }
  elsif ( $respcode >= 500 ) {
    print STDERR "General error: %s\n", $response->decoded_content();
    return 1;
  }
  elsif ( ! $response->is_success() ) {
    print STDERR "Error calling backend service, code %d\n", $response->code;
    return 1;
  }

  return 0;
}  # End of HandleRequest()


######################################################################
# DLCallBack:
#
# A call back for LWP downloading in HandleRequest().
#
# Write received data to standard output.
######################################################################
sub DLCallBack {
  my ($data, $response, $protocol) = @_;

  # If HTTP request was a success write returned content directly to STDOUT.
  if ( $response->is_success() ) {
    print STDOUT $data;
  }
}


######################################################################
# ReadRequest:
#
# Read request parameters from the parsed command line arguments or
# from STDIN, perform some initial validation and populate these
# global variables:
#
#  $quality       : An optional single character request quality (or wildcard)
#  $minimumlength : An optional value for minimum segment length (seconds)
#  $longestonly   : A boolean value to request longest segment only (TRUE or FALSE)
#  @requests      : A list of request lines as in the following format:
#                    "Net Sta Loc Chan Starttime Endtime"
#
# A request supplied via command line arguments must include a start
# or end time to be.
#
# Returns 0 on success, otherwise an appropriate exit code.
######################################################################
sub ReadRequest () {
  my $retval = 0;

  # Check case of data selection via arguments but no time window specified
  if ( ($network || $station || $location || $channel) &&
       (! $starttime && ! $endtime) ) {
    print STDERR "Start and end times must be specified\n";
    return 3;
  }

  # If command line selection of start/end times add a data request entry
  if ( $starttime || $endtime ) {
    if ( ! $network && ! $station && ! $location && ! $channel ) {
      print STDERR "No channels specified, too much data selected\n";
      return 4;
    }

    # Unspecified parameters are logically equivalent to all
    $network ="*" if ( ! $network );
    $station ="*" if ( ! $station );
    $location ="*" if ( ! $location );
    $channel ="*" if ( ! $channel );

    if ( $verbose >= 1 ) {
      print STDERR "Adding request: $network $station $location $channel $starttime $endtime\n";
    }

    push (@requests, "$network $station $location $channel $starttime $endtime");
  }

  # If --STDIN is specified expect selections from stdin
  $selectfile = "-" if ( $selectstdin );

  # Read selection file/stdin if supplied
  if ( $selectfile ) {
    print STDERR "Opening $selectfile\n" if ( $verbose );

    if ( ! open (SF, $selectfile) ) {
      print STDERR "Cannot open $selectfile: $?\n";
      return 1;
    }

    # Read selection file and determine input files
    foreach my $sline ( <SF> ) {
      # Trim trailing newlines and white spaces
      chomp $sline;
      $sline =~ s/\s*$//;

      my ($qual) = $sline =~ /^quality\=(.+)/i;
      my ($msl) = $sline =~ /^minimumlength\=(.+)/i;
      my ($lso) = $sline =~ /^longestonly\=(.+)/i;
      my ($for) = $sline =~ /^format\=(.+)/i;
      my ($net,$sta,$loc,$chan,$start,$end) = split (' ', $sline);

      if ( $qual ) {
	$quality = $qual;
      }
      elsif ( $msl ) {
	$minimumlength = $msl;
      }
      elsif ( $lso ) {
	$longestonly = $lso;
      }
      elsif ( $for ) {
        $format = $for;
      }
      elsif ( $end ) {
	if ( $verbose >= 1 ) {
	  print STDERR "Adding request: $net $sta $loc $chan $start $end\n";
	}

	push (@requests, "$net $sta $loc $chan $start $end");
      }
      else {
	print STDERR "Unrecognized data selection: '$sline'\n";
	$retval = 3;
      }

      close SF;
    }
  }

  return $retval;
}  # End of ReadRequest()


######################################################################
# ValidateRequest:
#
# Validate the data selection parameter values and print specific
# errors to STDERR.  Start and end time are required, validation will
# fail if they are not specified.
#
# Expected date-time formats are one of:
#
# YYYY-MM-DD[T ]HH:MM:SS.ssssss
# YYYY-MM-DD[T ]HH:MM:SS
# YYYY-MM-DD
#
# Month, day, hour, min and second values may be single digits.
#
# If specified, network, station, location and channel are
# validated for length and characters allowed in the SEED 2.4
# specification or wildcards.
#
# Name parameter lists: each of network, station, location and channel
# may contain a list of comma separated values, which may futher
# contain wildcards.  For example, the channel value may contain
# "LHE,LHN,LHZ" or "LH?,BH?".
#
# Returns 0 on success, otherwise an appropriate exit code.
######################################################################
sub ValidateRequest () {
  my $retval = 0;

  # Validate quality option, a single character from "DRQMB*?"
  if ( $quality && $quality !~ /^[DRQMB\*\?]$/ ) {
    print STDERR "Unrecognized quality selection [D,R,Q,M,B,?,*]: '$quality'\n";
    $retval = 3;
  }

  # Validate longestonly option, must be TRUE or FALSE case insensitive
  if ( $longestonly && ($longestonly !~ /^TRUE$/i && $longestonly !~ /^FALSE$/i) ) {
    print STDERR "Unrecognized value for longestonly [TRUE or FALSE]: '$longestonly'\n";
    $retval = 3;
  }

  # Validate minimumlength option, must be a decimal value
  if ( $minimumlength && $minimumlength !~ /^\d+(\.\d+)?$/ ) {
    print STDERR "Unrecognized value for minimumlength [decimal seconds]: '$minimumlength'\n";
    $retval = 3;
  }

  # Validate format option, must be MINISEED or MSEED
  if ( $format && ($format !~ /^MINISEED$/i && $format !~ /^MSEED$/i) ) {
    print STDERR "Unrecognized value for format [MINISEED]: '$format'\n";
    $retval = 3;
  }

  # Validating each selection line
  foreach my $req ( @requests ) {
    chomp $req;
    my ($net,$sta,$loc,$chan,$start,$end) = split (' ', $req);

    if ( $verbose >= 2 ) {
      print STDERR "Validating request: $net $sta $loc $chan $start $end\n";
    }

    if ( $net ) {
      foreach my $n ( split (/,/, $net) ) {
	if ( $n !~ /^[A-Za-z0-9\*\?]{1,2}$/ ) {
	  print STDERR "Unrecognized network code [1-2 characters]: '$n'\n";
	  $retval = 3;
	}
      }
    }

    if ( $sta ) {
      foreach my $s ( split (/,/, $sta) ) {
	if ( $s !~ /^[A-Za-z0-9\*\?]{1,5}$/ ) {
	  print STDERR "Unrecognized station code [1-5 characters]: '$s'\n";
	  $retval = 3;
	}
      }
    }

    if ( $loc ) {
      foreach my $l ( split (/,/, $loc) ) {
	if ( $l !~ /^[A-Za-z0-9\-\*\?]{1,2}$/ ) {
	  print STDERR "Unrecognized location ID [1-2 characters]: '$l'\n";
	  $retval = 3;
	}
      }
    }

    if ( $chan ) {
      foreach my $c ( split (/,/, $chan) ) {
	if ( $c !~ /^[A-Za-z0-9\*\?]{1,3}$/ ) {
	  print STDERR "Unrecognized channel codes [1-3 characters]: '$c'\n";
	  $retval = 3;
	}
      }
    }

    if ( ! $start ) {
      print STDERR "Start time must be specified\n";
      $retval = 3;
    }
    elsif ( $start !~ /^\d{4}-[01]?\d-[0-3]?\d[T ][0-2]?\d:[0-5]?\d:[0-5]?\d\.\d+(Z)?$/ &&
	    $start !~ /^\d{4}-[01]?\d-[0-3]?\d[T ][0-2]?\d:[0-5]?\d:[0-5]?\d(Z)?$/ &&
	    $start !~ /^\d{4}-[01]?\d-[0-3]?\d(Z)?$/ ) {
      print STDERR "Unrecognized start time [YYYY-MM-DDTHH:MM:SS.ssssss]: '$start'\n";
      $retval = 3;
    }

    if ( ! $end ) {
      print STDERR "End time must be specified\n";
      $retval = 3;
    }
    elsif ( $end !~ /^\d{4}-[01]?\d-[0-3]?\d[T ][0-2]?\d:[0-5]?\d:[0-5]?\d\.\d+(Z)?$/ &&
	    $end !~ /^\d{4}-[01]?\d-[0-3]?\d[T ][0-2]?\d:[0-5]?\d:[0-5]?\d(Z)?$/ &&
	    $end !~ /^\d{4}-[01]?\d-[0-3]?\d(Z)?$/ ) {
      print STDERR "Unrecognized end time [YYYY-MM-DDTHH:MM:SS.ssssss]: '$end'\n";
      $retval = 3;
    }

    # Check for impossible time windows
    my $startepoch = str2time ($start, "UTC");
    my $endepoch = str2time ($end, "UTC");

    if ( $startepoch > $endepoch ) {
      print STDERR "Start time must be before end time, start: '$start', end: '$end'\n";
      $retval = 3;
    }
  }

  return $retval;
}  # End of ValidateRequest()
