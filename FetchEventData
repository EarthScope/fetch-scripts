#!/usr/bin/perl
#
# FetchEventData
#
# Find the most current version at http://service.iris.edu/clients/
#
# Fetch selected event parameters and event-windowed time series data
# from the DMC web service interfaces.
#
# Dependencies: This script should run without problems on Perl
# release 5.10 or newer, older versions of Perl might require the
# installation of the following modules (and their dependencies):
#   Bundle::LWP (libwww-perl)
#
#
# ## Change history ##
#
# 2012.329:
#  - Initial version.
#
# 2013.198
#  - Add test for minimum version of LWP (libwww) module of 5.806.
#
# Author: Chad Trabant, IRIS Data Managment Center

use strict;
use File::Basename;
use Getopt::Long;
use LWP 5.806; # Require minimum version
use LWP::UserAgent;
use HTTP::Status qw(status_message);
use HTTP::Date;
use Time::HiRes;
use Math::Trig;

my $version = "2013.198";

my $scriptname = basename($0);

# Web service for event information
my $eventservice = 'http://service.iris.edu/fdsnws/event/1/';

# Web service for station metadata
my $metadataservice = 'http://service.iris.edu/fdsnws/station/1/';

# Web service for bulk waveform data
my $waveformservice = 'http://service.iris.edu/fdsnws/dataselect/1/';

# Web service for travel time calculations
my $traveltimeservice = 'http://service.iris.edu/irisws/traveltime';

# HTTP UserAgent reported to web services
my $useragent = "$scriptname/$version Perl/$] " . new LWP::UserAgent->_agent;

# Recongized phase list
my @phaselist = ('p','s','P','S','Pn','Sn','Pdiff','Sdiff','PKP','SKS','PKiKP','SKiKS','PKIKP','SKIKS');
my @phases = ();

my $usage      = undef;
my $verbose    = undef;
my $nobsprint  = undef;
my $appname    = undef;
my $auth       = undef;
my $outdir     = undef;

# Event selection
my $eventstart = undef;
my $eventend   = undef;
my @latrange   = ();      # (minlat:maxlat)
my @lonrange   = ();      # (minlon:maxlon)
my @degrange   = ();      # (lat:lon:maxradius[:minradius])
my @deprange   = ();      # (mindepth:maxdepth)
my @magrange   = ();      # (minmag:maxmag)
my $magtype    = undef;
my $catalog    = undef;
my $eventid    = undef;
my $eventfile  = undef;

# Data selection
my $datastart  = undef;
my $dataend    = undef;
my $net        = undef;
my $sta        = undef;
my $loc        = undef;
my $chan       = undef;
my $qual       = "B";
my $datafile   = undef;

my @phases = ();

# List of selected events in the following format:
# EventID|Time|Latitude|Longitude|Depth|Author|Catalog|Contributor|ContributorID|MagType|Magnitude|MagAuthor|EventLocationName
my @events     = ();

# List of selected channels in the following format:
# Network|Station|Location|Channel|Latitude|Longitude|Elevation|Depth|Azimuth|Dip|Instrument|Scale|ScaleFreq|ScaleUnits|SampleRate|StartTime|EndTime
my @channels   = ();

my $inflater   = undef;

# If Compress::Raw::Zlib is available configure inflater for RFC 1952 (gzip)
if ( eval("use Compress::Raw::Zlib; 1") ) {
  use Compress::Raw::Zlib; 
  $inflater = new Compress::Raw::Zlib::Inflate( -WindowBits => WANT_GZIP,
						-ConsumeInput => 0 );
}

# Parse command line arguments
Getopt::Long::Configure ("bundling_override");
my $getoptsret = GetOptions ( 'help|usage|h'    => \$usage,
                              'verbose|v+'      => \$verbose,
                              'nobs'            => \$nobsprint,
			      'appname|A=s'     => \$appname,
			      'auth|a=s'        => \$auth,
			      'outdir|d=s'      => \$outdir,

			      'eventstart|es=s' => \$eventstart,
			      'eventend|ee=s'   => \$eventend,
			      'lat=s'           => \@latrange,
                              'lon=s'           => \@lonrange,
                              'radius=s'        => \@degrange,
			      'depth=s'         => \@deprange,
			      'mag=s'           => \@magrange,
			      'magtype=s'       => \$magtype,
                              'catalog|cat=s'   => \$catalog,
			      'eventid|evid=s'  => \$eventid,
			      'eventfile=s'     => \$eventfile,

                              'datastart|ds=s'  => \$datastart,
                              'dataend|de=s'    => \$dataend,
                              'net|N=s'         => \$net,
                              'sta|S=s'         => \$sta,
                              'loc|L=s'         => \$loc,
                              'chan|C=s'        => \$chan,
                              'qual|Q=s'        => \$qual,
                              'datafile=s'      => \$datafile,
			    );

my $erequired =  ( defined $eventstart || defined $eventend ||
		   scalar @latrange || scalar @lonrange || scalar @degrange ||
		   scalar @deprange || scalar @magrange ||
		   defined $catalog || defined $eventid );

my $drequired =  ( defined $net || defined $sta || defined $chan );

if ( ! $getoptsret || $usage || ! ($erequired || $eventfile) || ! ($drequired || $datafile) ) {
  print "$scriptname: Fetch event windowed waveforms from the IRIS DMC ($version)\n";
  print "http://www.iris.edu/ws/wsclients/\n\n";
  print "Usage: $scriptname [options]\n\n";
  print " Options:\n";
  print " -v                More verbosity, may be specified multiple times (-vv, -vvv)\n";
  print "\n";
  print "Event selection:\n";
  print " -es eventstart    Limit to origins after time (YYYY-MM-DD,HH:MM:SS.sss)\n";
  print " -ee eventend      Limit to origins before time (YYYY-MM-DD,HH:MM:SS.sss)\n";
  print " --lat min:max     Specify a minimum and/or maximum latitude range\n";
  print " --lon min:max     Specify a minimum and/or maximum longitude range\n";
  print " --radius lat:lon:maxradius[:minradius]\n";
  print "                     Specify circular region with optional minimum radius\n";
  print " --depth min:max   Specify a minimum and/or maximum depth in kilometers\n";
  print " --mag min:max     Specify a minimum and/or maximum magnitude\n";
  print " --magtype type    Specify a magnitude type for magnitude range limits\n";
  print " --cat name        Limit to origins from specific catalog (e.g. ISC, PDE, GCMT)\n";
  print " --evid id         Select a specific event by DMC event ID\n";
  print "\n";
  print "Data selection:\n";
  print " -N,--net          Network code, list and wildcards (* and ?) accepted\n";
  print " -S,--sta          Station code, list and wildcards (* and ?) accepted\n";
  print " -L,--loc          Location ID, list and wildcards (* and ?) accepted\n";
  print " -C,--chan         Channel codes, list and wildcards (* and ?) accepted\n";
  print " -Q,--qual         Quality indicator, default is best\n";
  print " -ds datastart     Specify data start time (YYYY-MM-DD,HH:MM:SS.ssssss)\n";
  print " -de dataend       Specify data end time (YYYY-MM-DD,HH:MM:SS.ssssss)\n";
  print "\n";
  print " -A appname        Application/version string for identification\n";
#  print " -a user:pass      User and password when authentication is needed\n";
  print "\n";
  print " -o outdir         Specify data output directory, one directory per event\n";
  print "\n";
  exit 1;
}

# Print script name and local time string
if ( $verbose ) {
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  printf STDERR "$scriptname ($version) at %4d-%02d-%02d %02d:%02d:%02d\n", $year+1900, $mon+1, $mday, $hour, $min, $sec;
}

if ( $datastart ) {
  if ($datastart =~ /[A-Za-z]+[\+\-][0-9\.]+/ || $datastart =~ /[0-9\.]+[\+\-][A-Za-z]+/) {
    
  }
  else {
    $datastart = &NormalizeTimeString($datastart);
  }
}
if ( $dataend ) {
  if ($dataend =~ /[A-Za-z]+[\+\-][0-9\.]+/ || $dataend =~ /[0-9\.]+[\+\-][A-Za-z]+/) {
    
  }
  else {
    $dataend = &NormalizeTimeString($dataend);
  }
}

# Normalize event time strings
$eventstart = &NormalizeTimeString($eventstart) if ( $eventstart );
$eventend = &NormalizeTimeString($eventend) if ( $eventend );



# Validate and prepare lat, lon and radius input
if ( scalar @latrange ) {
  @latrange = split (/:/, $latrange[0]);

  if ( defined $latrange[0] && ($latrange[0] < -90.0 || $latrange[0] > 90.0) ) {
    die "Minimum latitude out of range: $latrange[0]\n";
  }
  if ( defined $latrange[1] && ($latrange[1] < -90.0 || $latrange[1] > 90.0) ) {
    die "Maximum latitude out of range: $latrange[1]\n";
  }
}
if ( scalar @lonrange ) {
  @lonrange = split (/\:/, $lonrange[0]);

  if ( defined $lonrange[0] && ($lonrange[0] < -180.0 || $lonrange[0] > 180.0) ) {
    die "Minimum longitude out of range: $lonrange[0]\n";
  }
  if ( defined $lonrange[1] && ($lonrange[1] < -180.0 || $lonrange[1] > 180.0) ) {
    die "Maximum longitude out of range: $lonrange[1]\n";
  }
}
if ( scalar @degrange ) {
  @degrange = split (/\:/, $degrange[0]);

  if ( scalar @degrange < 3 || scalar @degrange > 4 ) {
    die "Unrecognized radius specification: @degrange\n";
  }
  if ( defined $degrange[0] && ($degrange[0] < -90.0 || $degrange[0] > 90.0) ) {
    die "Radius latitude out of range: $degrange[0]\n";
  }
  if ( defined $degrange[1] && ($degrange[1] < -180.0 || $degrange[1] > 180.0) ) {
    die "Radius longitude out of range: $degrange[1]\n";
  }
}
if ( scalar @deprange ) {
  @deprange = split (/\:/, $deprange[0]);

  if ( defined $deprange[0] && ($deprange[0] < -7000 || $deprange[0] > 7000) ) {
    die "Minimum depth out of range: $deprange[0]\n";
  }
  if ( defined $deprange[1] && ($deprange[1] < -7000 || $deprange[1] > 7000) ) {
    die "Maximum depth out of range: $deprange[1]\n";
  }
}
if ( scalar @magrange ) {
  @magrange = split (/\:/, $magrange[0]);

  if ( defined $magrange[0] && ($magrange[0] < -50 || $magrange[0] > 15) ) {
    die "Minimum magnitude out of range: $magrange[0]\n";
  }
  if ( defined $magrange[1] && ($magrange[1] < -50 || $magrange[1] > 15) ) {
    die "Maximum magnitude out of range: $magrange[1]\n";
  }
}

# Report event selection criteria
if ( $verbose > 2 ) {
  print STDERR "Latitude range: $latrange[0] : $latrange[1]\n" if ( scalar @latrange );
  print STDERR "Longitude range: $lonrange[0] : $lonrange[1]\n" if ( scalar @lonrange );
  print STDERR "Radius range: $degrange[0] : $degrange[1] : $degrange[2] : $degrange[3]\n" if ( scalar @degrange );
  print STDERR "Depth range: $deprange[0] : $deprange[1]\n" if ( scalar @deprange );
  print STDERR "Magnitude range: $magrange[0] : $magrange[1]\n" if ( scalar @magrange );
}

my $eventbuffer = undef;
my $eventrecvsize = undef;
my $channelbuffer = undef;
my $channelrecvsize = undef;

# Fetch and/or read events
&FetchEvents() if ( $erequired );
#&ReadEventFile() if ( $eventfile );

printf STDERR "Selected %d events\n", scalar @events if ( $verbose );

foreach my $event ( @events ) {
  # EventID|Time|Latitude|Longitude|Depth|Author|Catalog|Contributor|ContributorID|MagType|Magnitude|MagAuthor|EventLocationName
  my ($evid,$etime,$elat,$elon,$edepth,$eauthor,$ecatalog,$econtributor,$econtributorid,$emagtype,$emag,$emagauthor,$elocationname)
    = split (/\|/, $event);

  $etime = &NormalizeTimeString ($etime);

  # Fetch channel metadata for this event, match naming criteria with 30 minute window
  my $cstart = $etime;
  my $cend = &AddTimeToTimeString ($etime, 1800.0);

  print STDERR "Fetching channel metadata for $emagtype $emag $elocationname ($evid) $etime\n" if ( $verbose );
  print STDERR "  Channel start: $cstart,  Channel end: $cend\n" if ( $verbose > 1 );

  # Fetch list of selected channels for this event
  @channels = ();
  FetchMetaData($net,$sta,$loc,$chan,$cstart,$cend);

  # Default request window is 30 after origin time
  my $rstart = ( $datastart ) ? $datastart : $etime;
  my $rend = ( $dataend ) ? $dataend : &AddTimeToTimeString ($etime, 1800.0);

  # Build request from channel list and requested time window
  my @requests = ();
  foreach my $channel ( @channels ) {
    #Network|Station|Location|Channel|Latitude|Longitude|Elevation|Depth|Azimuth|Dip|Instrument|Scale|ScaleFreq|ScaleUnits|SampleRate|StartTime|EndTime
    my ($net,$sta,$loc,$chan,$slat,$slon,$selev,$sdepth,$sazimuth,$sdip,$sinstrument,$sscale,$sscalefreq,$sscaleunits,$ssamprate,$sstarttime,$sendtime)
      = split (/\|/, $channel);

    $loc =~s/ /\-/g;  # Translate location's spaces " " to dashes"-"

    my ($distance) = &distaz ($elat, $elon, $slat, $slon);
    $distance = sprintf ("%.3f", $distance);

    push (@requests, [$net,$sta,$loc,$chan,$rstart,$rend,$distance]);
  }

#CHAD, need to identify when datastart/end needs to be determined from travel times.

  if ( $rstart =~ /[A-Za-z]+[\+\-][0-9\.]+/ || $rstart =~ /[0-9\.]+[\+\-][A-Za-z]+/ ||
       $rend =~ /[A-Za-z]+[\+\-][0-9\.]+/ || $rend =~ /[0-9\.]+[\+\-][A-Za-z]+/ ) {

    print"Found phase-based time selection: $rstart TO $rend \n";
  }

  foreach my $reqref ( @requests ) {
    print STDERR "REQUEST: @$reqref\n";
  }

}

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
printf STDERR "DONE at %4d-%02d-%02d %02d:%02d:%02d\n", $year+1900, $mon+1, $mday, $hour, $min, $sec;
## End of main




######################################################################
# FetchEvents:
#
# Collect event information for selected data set.  The returned
# events are added to the global @events list.
#
######################################################################
sub FetchEvents {

  # Create HTTP user agent
  my $ua = RequestAgent->new();

  # Create web service URI
  my $uri = "${eventservice}/query?";
  $uri .= "format=text";
  $uri .= "&orderby=time";
  $uri .= "&starttime=$eventstart" if ( $eventstart );
  $uri .= "&endtime=$eventend" if ( $eventend );
  if ( scalar @latrange ) {
    $uri .= "&minlat=$latrange[0]" if ( defined $latrange[0] );
    $uri .= "&maxlat=$latrange[1]" if ( defined $latrange[1] );
  }
  if ( scalar @lonrange ) {
    $uri .= "&minlon=$lonrange[0]" if ( defined $lonrange[0] );
    $uri .= "&maxlon=$lonrange[1]" if ( defined $lonrange[1] );
  }
  if ( scalar @degrange ) {
    $uri .= "&lat=$degrange[0]" if ( defined $degrange[0] );
    $uri .= "&lon=$degrange[1]" if ( defined $degrange[1] );
    $uri .= "&maxradius=$degrange[2]" if ( defined $degrange[2] );
    $uri .= "&minradius=$degrange[3]" if ( defined $degrange[3] );
  }
  if ( scalar @deprange ) {
    $uri .= "&mindepth=$deprange[0]" if ( defined $deprange[0] );
    $uri .= "&maxdepth=$deprange[1]" if ( defined $deprange[1] );
  }
  if ( scalar @magrange ) {
    $uri .= "&minmag=$magrange[0]" if ( defined $magrange[0] );
    $uri .= "&maxmag=$magrange[1]" if ( defined $magrange[1] );
  }
  $uri .= "&magtype=$magtype" if ( $magtype );
  $uri .= "&catalog=$catalog" if ( $catalog );
  $uri .= "&eventId=$eventid" if ( $eventid );

  my $ftime = Time::HiRes::time;

  print STDERR "Event URI: '$uri'\n" if ( $verbose > 2 );

  print STDERR "Fetching event information :: " if ( $verbose > 1 );

  $eventbuffer = "";
  $eventrecvsize = 0;

  # Fetch event information from web service using callback routine
  # Also request compressed content if support exists
  my $response = ( $inflater ) ?
    $ua->get($uri, 'Accept-Encoding' => 'gzip', ':content_cb' => \&EDCallBack ) :
    $ua->get($uri, ':content_cb' => \&EDCallBack );

  $inflater->inflateReset if ( $inflater );

  if ( $response->code == 404 || $response->code == 204 ) {
    print (STDERR "No data available\n") if ( $verbose );
    return;
  }
  elsif ( ! $response->is_success() ) {
    print (STDERR "Error fetching data: "
	   . $response->code . " :: " . status_message($response->code) . "\n");
    print STDERR "------\n" . $response->decoded_content . "\n------\n";
    print STDERR "  URI: '$uri'\n" if ( $verbose > 1 );
  }
  else {
    printf (STDERR "%s\n", ($nobsprint)?sizestring($eventrecvsize):"") if ( $verbose > 1 );
  }

  my $duration = Time::HiRes::time - $ftime;
  my $rate = $eventrecvsize/(($duration)?$duration:0.000001);
  printf (STDERR "Received %s of event information in %.1f seconds (%s/s)\n",
	  sizestring($eventrecvsize), $duration, sizestring($rate));

  # Return if no data received
  return if ( length $eventbuffer <= 0 );

  my $ptime = Time::HiRes::time;

  print STDERR "Parsing event data... " if ( $verbose > 1 );

  # Add to list of events
  my $totalevents = 0;

  foreach my $event ( split(/\n+/, $eventbuffer) ) {
    next if ( $event =~ /^#/ );
    chomp($event);
    push (@events, $event);
    $totalevents++;
  }

  printf STDERR "Done (%.1f seconds)\n", Time::HiRes::time - $ptime if ( $verbose > 1 );

  my $duration = Time::HiRes::time - $ftime;
  my $rate = (length $eventbuffer)/(($duration)?$duration:0.000001);
  printf (STDERR "Processed event information for $totalevents events in %.1f seconds (%s/s)\n",
	  $duration, sizestring($rate));


} # End of FetchEvents()


######################################################################
# EDCallBack:
#
# A call back for LWP downloading.
######################################################################
sub EDCallBack {
  my ($data, $response, $protocol) = @_;
  $eventrecvsize += length($data);

  if ( $response->content_encoding() =~ /gzip/ ) {
    my $datablock;
    $inflater->inflate($data, $datablock);
    $eventbuffer .= $datablock;
  }
  else {
    $eventbuffer .= $data;
  }

  if ( $verbose > 1 && ! $nobsprint ) {
    printf (STDERR "%-10.10s\b\b\b\b\b\b\b\b\b\b", sizestring($eventrecvsize));
  }
}


######################################################################
# FetchMetaData:
#
# Collect channel metadata for selected data set.  The returned
# channels are added to the global @channels list.
#
######################################################################
sub FetchMetaData {
  my ($rnet,$rsta,$rloc,$rchan,$rstart,$rend) = @_;

  # Create HTTP user agent
  my $ua = RequestAgent->new();

  my $level = "chan";

  # Create web service URI
  my $uri = "${metadataservice}/query?";
  $uri .= "format=text";
  $uri .= "&level=channel";
  $uri .= "&network=$rnet" if ( $rnet );
  $uri .= "&station=$rsta" if ( $rsta );
  $uri .= "&location=$rloc" if ( $rloc );
  $uri .= "&channel=$rchan" if ( $rchan );
  $uri .= "&starttime=$rstart" if ( $rstart );
  $uri .= "&endtime=$rend" if ( $rend );

  my $ftime = Time::HiRes::time;

  print STDERR "Channel metadata URI: '$uri'\n" if ( $verbose > 2 );

  print STDERR "Fetching channel metadata :: " if ( $verbose > 1 );

  $channelbuffer = "";
  $channelrecvsize = 0;

  # Fetch channel information from web service using callback routine
  # Also request compressed content if support exists
  my $response = ( $inflater ) ?
    $ua->get($uri, 'Accept-Encoding' => 'gzip', ':content_cb' => \&MDCallBack ) :
    $ua->get($uri, ':content_cb' => \&MDCallBack );

  $inflater->inflateReset if ( $inflater );

  if ( $response->code == 404 || $response->code == 204 ) {
    print (STDERR "No data available\n") if ( $verbose );
    return;
  }
  elsif ( ! $response->is_success() ) {
    print (STDERR "Error fetching data: "
	   . $response->code . " :: " . status_message($response->code) . "\n");
    print STDERR "------\n" . $response->decoded_content . "\n------\n";
    print STDERR "  URI: '$uri'\n" if ( $verbose > 1 );
  }
  else {
    printf (STDERR "%s\n", ($nobsprint)?sizestring($channelrecvsize):"") if ( $verbose > 1 );
  }

  my $duration = Time::HiRes::time - $ftime;
  my $rate = $channelrecvsize/(($duration)?$duration:0.000001);
  printf (STDERR "Received %s of channel metadata in %.1f seconds (%s/s)\n",
	  sizestring($channelrecvsize), $duration, sizestring($rate));

  # Return if no channel metadata received
  return if ( length $channelbuffer <= 0 );

  my $ptime = Time::HiRes::time;

  print STDERR "Parsing channel metadata... " if ( $verbose > 1 );

  # Add to list of channels
  my $totalchannels = 0;

  foreach my $channel ( split(/\n+/, $channelbuffer) ) {
    next if ( $channel =~ /^#/ );
    chomp($channel);
    push (@channels, $channel);
    $totalchannels++;
  }

  printf STDERR "Done (%.1f seconds)\n", Time::HiRes::time - $ptime if ( $verbose > 1 );

  my $duration = Time::HiRes::time - $ftime;
  my $rate = $channelrecvsize/(($duration)?$duration:0.000001);
  printf (STDERR "Processed metadata for $totalchannels channels in %.1f seconds (%s/s)\n",
	  $duration, sizestring($rate));

} # End of FetchMetaData()


######################################################################
# MDCallBack:
#
# A call back for LWP downloading.
######################################################################
sub MDCallBack {
  my ($data, $response, $protocol) = @_;
  $channelrecvsize += length($data);

  if ( $response->content_encoding() =~ /gzip/ ) {
    my $datablock = "";
    $inflater->inflate($data, $datablock);
    $channelbuffer .= $datablock;
  }
  else {
    $channelbuffer .= $data;
  }

  if ( $verbose > 1 && ! $nobsprint ) {
    printf (STDERR "%-10.10s\b\b\b\b\b\b\b\b\b\b", sizestring($channelrecvsize));
  }
}


######################################################################
# AddTimeToTimeString (timestr, seconds):
#
# Return a clean size string for a given byte count.
######################################################################
sub AddTimeToTimeString {
  my $timestr = shift;
  my $seconds = shift;

  return undef if ( ! $seconds );

  my $depoch = &mdtimestr2epoch ($timestr) + $seconds;

  return &NormalizeTimeString(&epoch2mdtimestr ($depoch));
} # End of AddTimeToTimeString()


######################################################################
# NormalizeTimeString (timestr):
#
# Return a time size string in a consistent format.
######################################################################
sub NormalizeTimeString {
  my $timestr = shift;

  my ($year,$month,$mday,$hour,$min,$sec,$subsec) = split (/[-:,.\s\/T]/, $timestr);
  $timestr = sprintf ("%04d-%02d-%02dT%02d:%02d:%02d", $year, $month, $mday, $hour, $min, $sec);
  $timestr .= ".$subsec" if ( $subsec );

  return $timestr;
}


######################################################################
# sizestring (bytes):
#
# Return a clean size string for a given byte count.
######################################################################
sub sizestring { # sizestring (bytes)
  my $bytes = shift;

  if ( $bytes < 1000 ) {
    return sprintf "%d Bytes", $bytes;
  }
  elsif ( ($bytes / 1024) < 1000 ) {
    return sprintf "%.1f KB", $bytes / 1024;
  }
  elsif ( ($bytes / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f MB", $bytes / 1024 / 1024;
  }
  elsif ( ($bytes / 1024 / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f GB", $bytes / 1024 / 1024 / 1024;
  }
  elsif ( ($bytes / 1024 / 1024 / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f TB", $bytes / 1024 / 1024 / 1024 / 1024;
  }
  else {
    return "";
  }
} # End of sizestring()


######################################################################
#
# Package RequestAgent: a superclass for LWP::UserAgent with override
# of LWP::UserAgent methods to set default user agent and handle
# authentication credentials.
#
######################################################################
BEGIN {
  use LWP;
  package RequestAgent;
  our @ISA = qw(LWP::UserAgent);

  sub new
    {
      my $self = LWP::UserAgent::new(@_);
      my $fulluseragent = $useragent;
      $fulluseragent .= " ($appname)" if ( $appname );
      $self->agent($fulluseragent);
      $self;
    }

  sub get_basic_credentials
    {
      my ($self, $realm, $uri) = @_;

      if ( defined $auth ) {
        return split(':', $auth, 2);
      }
      elsif (-t) {
        my $netloc = $uri->host_port;
        print "\n";
        print "Enter username for $realm at $netloc: ";
        my $user = <STDIN>;
        chomp($user);
        return (undef, undef) unless length $user;
        print "Password: ";
        system("stty -echo");
        my $password = <STDIN>;
        system("stty echo");
        print "\n";  # because we disabled echo
        chomp($password);
        return ($user, $password);
      }
      else {
        return (undef, undef)
      }
    }
} # End of LWP::UserAgent override



############################################################################
# distaz (lat1, lon1, lat2, lon2)
#
# Calculate delta (angular distance) and azimuth between two
# geographic/geodetic coordinates.  The returned azimuth and
# back-azimuth are with respect to the first coordinate pair.
# Latitudes are converted to geocentric latitudes using the WGS84
# spheriod to correct for ellipticity.
#
############################################################################
sub distaz {
  my ($lat1, $lon1, $lat2, $lon2) = @_;

  # Major and minor axies for WGS84 spheriod
  my $semimajor = 6378137.0;
  my $semiminor = 6356752.3142;

  my $ratio2 = (($semiminor * $semiminor) / ($semimajor * $semimajor));

  my $pirad  = acos(-1.0) / 180.0;
  my $halfpi = acos(-1.0) / 2;

  # Convert latitude to geocentric coordinates
  my $nlat1 = atan ($ratio2 * tan ($lat1 * $pirad));
  my $nlat2 = atan ($ratio2 * tan ($lat2 * $pirad));

  # Great circle calculation for delta and azimuth
  my $gamma = ($lon2 - $lon1) * $pirad;
  my $a = ($halfpi - $nlat2);
  my $b = ($halfpi - $nlat1);

  my $sita;
  my $bsita;

  if ( $a == 0.0 ) {
    $sita = 1.0;
  }
  elsif ( $nlat2 == 0.0 ) {
    $sita = 0.0;
  }
  else {
    $sita = sin($b) / tan($a);
  }

  if ( $b == 0.0 ) {
    $bsita = 1.0;
  }
  elsif ( $nlat1 == 0.0 ) {
    $bsita = 0.0;
  }
  else {
    $bsita = sin($a) / tan($b);
  }

  my $delta = acos (cos($a) * cos($b) + sin($a) * sin($b) * cos($gamma)) / $pirad;

  my $azimuth = atan2 (sin($gamma), $sita - cos($gamma) * cos($b)) / $pirad;
  $azimuth = 0.0 if ( abs($azimuth) < 0.000001 );
  $azimuth += 360 if ( $azimuth < 0.0 );

  my $backazimuth = atan2 (-sin($gamma), $bsita - cos($gamma) * cos($a)) / $pirad;
  $backazimuth = 0.0 if ( abs($backazimuth) < 0.000001 );
  $backazimuth += 360 if ( $backazimuth < 0.0 );

  return ($delta, $azimuth, $backazimuth);
}


############################################################################
# TimeConv.pm
#
# Time conversion routines in Perl
#
# version 2012.315
#
# Chad Trabant, IRIS Data Management Center
############################################################################

use strict;

############################################################################
# time2epoch:
#
# Compute a double precision Unix/POSIX epoch time from the specified
# year, day-of-year, hours, minutes, seconds and microseconds.
#
# Returns a double precision epoch time
############################################################################
sub time2epoch { # time2epoch (year,yday,hour,min,sec,usec)
  my $year = shift;
  my $yday = shift;
  my $hour = shift;
  my $min = shift;
  my $sec = shift;
  my $usec = shift;

  if ( ! defined $year ) { $year = 0; }
  if ( ! defined $yday ) { $yday = 1; }
  if ( ! defined $hour ) { $hour = 0; }
  if ( ! defined $min ) { $min = 0; }
  if ( ! defined $sec ) { $sec = 0; }
  if ( ! defined $usec ) { $usec = 0; }

  # Calculate epoch
  my $shortyear = $year - 1900;
  my $a4 = int (($shortyear >> 2) + 475 - ! ($shortyear & 3));
  my $a100 = int ($a4 / 25 - (($a4 % 25) < 0));
  my $a400 = int ($a100 >> 2);

  my $intervening_leap_days = ($a4 - 492) - ($a100 - 19) + ($a400 - 4);

  my $days = (365 * ($shortyear - 70) + $intervening_leap_days + ($yday - 1));

  my $epoch = (60 * (60 * (24 * $days + $hour) + $min) + $sec) + $usec / 1000000;

  return $epoch;
} # End of time2epoch()


############################################################################
# timestr2epoch:
#
# Compute a double precision Unix/POSIX epoch time by parsing a string
# containing the year, day-of-year, hours, minutes, seconds and
# microseconds.
#
# Example input string: "2006,141,10:11:33.12"
#
# Value : Range
# Year  : 1900 - 3000
# Yday  : 1 - 366
# Hour  : 0 - 23
# Min   : 0 - 59
# Sec   : 0 - 59
# Fract : No limit on the fraction seconds
#
# Returns a double precision epoch time
############################################################################
sub timestr2epoch { # timestr2epoch ("year,yday,hour:min:sec.fsec")
  my $timestr = shift;

  my ($year,$yday,$hour,$min,$sec,$fract) = split (/[-:,.\s\/]/,$timestr);

  # Sanity check all input values and set defaults
  if ( ! defined $year || $year < 1900 || $year > 3000 ) {
    print "time2epoch: year ($year) is out of range\n";
    return;
  }

  # Test for leap year
  my $leap = ( (($year%4 == 0) && ($year%100 != 0)) || ($year%400 == 0) ) ? 1 : 0;

  if ( ! defined $yday ) {
    $yday = 1;
  }
  elsif ( $yday > 365+$leap || $yday < 0 ) {
    print "time2epoch: day-of-year ($yday) is out of range\n";
    return;
  }
  if ( ! defined $hour ) {
    $hour = 0;
  }
  elsif ( $hour > 23 || $hour < 0 ) {
    print "time2epoch: hour ($hour) is out of range\n";
    return;
  }
  if ( ! defined $min ) {
    $min = 0;
  }
  elsif ( $min > 59 || $min < 0 ) {
    print "time2epoch: minute ($min) is out of range\n";
    return;
  }
  if ( ! defined $sec ) {
    $sec = 0;
  }
  elsif ( $sec > 59 || $sec < 0 ) {
    print "time2epoch: second ($sec) is out of range\n";
    return;
  }

  my $usec = 0;

  # Convert the fractional seconds to microseconds
  if ( defined $fract ) {
    my $flen = length $fract;
    $usec = $fract * (10 ** (6-$flen));
  }

  return time2epoch ($year,$yday,$hour,$min,$sec,$usec);
} # End of timestr2epoch()


############################################################################
# mdtimestr2epoch:
#
# Compute a double precision Unix/POSIX epoch time by parsing a string
# containing the year, month, day-of-month, hours, minutes, seconds and
# microseconds.
#
# Example input string: "2006/5/21 10:11:33.12"
#
# Value : Range
# Year  : 1900 - 3000
# Month : 1 - 12
# Mday  : 1 - 31
# Hour  : 0 - 23
# Min   : 0 - 59
# Sec   : 0 - 59
# Fract : No limit on the fraction seconds
#
# Returns a double precision epoch time
############################################################################
sub mdtimestr2epoch { # mdtimestr2epoch ("2006/5/21 10:11:33.12")
  my $mdtimestr = shift;

  my ($year,$month,$mday,$hour,$min,$sec,$fract) = split (/[-:,T.\s\/]/,$mdtimestr);

  my $yday = undef;

  if ( defined $year && defined $month && defined $mday ) {
    $yday = &md2doy ($year, $month, $mday);
  }

  # Sanity check all input values and set defaults
  if ( ! defined $year || $year < 1900 || $year > 3000 ) {
    print "time2epoch: year ($year) is out of range\n";
    return;
  }

  # Test for leap year
  my $leap = ( (($year%4 == 0) && ($year%100 != 0)) || ($year%400 == 0) ) ? 1 : 0;

  if ( ! defined $yday ) {
    $yday = 1;
  }
  elsif ( $yday > 365+$leap || $yday < 0 ) {
    print "time2epoch: day-of-year ($yday) is out of range\n";
    return;
  }
  if ( ! defined $hour ) {
    $hour = 0;
  }
  elsif ( $hour > 23 || $hour < 0 ) {
    print "time2epoch: hour ($hour) is out of range\n";
    return;
  }
  if ( ! defined $min ) {
    $min = 0;
  }
  elsif ( $min > 59 || $min < 0 ) {
    print "time2epoch: minute ($min) is out of range\n";
    return;
  }
  if ( ! defined $sec ) {
    $sec = 0;
  }
  elsif ( $sec > 59 || $sec < 0 ) {
    print "time2epoch: second ($sec) is out of range\n";
    return;
  }

  my $usec = 0;

  # Convert the fractional seconds to microseconds
  if ( defined $fract ) {
    my $flen = length $fract;
    $usec = $fract * (10 ** (6-$flen));
  }

  return time2epoch ($year,$yday,$hour,$min,$sec,$usec);
} # End of mdtimestr2epoch()


############################################################################
# epoch2time:
#
# Convert an epoch time to year, day-of-year, hour, minute, second and
# microseconds.
#
# Returns (year,yday,hour,min,sec,usec)
############################################################################
sub epoch2time { # epoch2time (epoch)
  my $epoch  = shift;

  return if ( ! defined $epoch );

  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday) = gmtime ($epoch);

  $year += 1900;
  $mon++;
  $yday++;

  my $usec = ($epoch - int $epoch) * 1000000;

  return ($year,$yday,$hour,$min,$sec,$usec);
} # End of epoch2time()


############################################################################
# epoch2timestr:
#
# Create a formatted time string from an epoch.
#
# Format: 'YYYY,DDD,HH:MM:SS.FFFFFF'
#
# Returns a formatted time string.
############################################################################
sub epoch2timestr { # epoch2timestr (epoch)
  my $epoch  = shift;

  return if ( ! defined $epoch );

  my ($year,$yday,$hour,$min,$sec,$usec) = epoch2time ($epoch);

  return sprintf ("%4d,%03d,%02d:%02d:%02d.%06d",
		  $year,$yday,$hour,$min,$sec,$usec);
} # End of epoch2timestr()


############################################################################
# epoch2mdtimestr:
#
# Create a month-day formatted time string from an epoch.
#
# Format: 'YYYY-MM-DD HH:MM:SS.FFFFFF'
#
# Returns a formatted time string.
############################################################################
sub epoch2mdtimestr { # epoch2mdtimestr (epoch)
  my $epoch  = shift;

  return if ( ! defined $epoch );

  my ($year,$yday,$hour,$min,$sec,$usec) = epoch2time ($epoch);

  my ($mon, $mday) = doy2md ($year, $yday);

  return sprintf ("%4d-%02d-%02d %02d:%02d:%02d.%06d",
		  $year,$mon,$mday,$hour,$min,$sec,$usec);
} # End of epoch2mdtimestr()


############################################################################
# doy2md:
#
# Compute the month and day-of-month (mday) from a year and
# day-of-year (yday).
#
# Year is expected to be in the range 1900-3000, jday is expected to
# be in the range 1-366, month will be in the range 1-12 and mday
# will be in the range 1-31
#
# Returns the month and day-of-month (mday)
############################################################################
sub doy2md {  # doy2md (year, yday)
  my $year = shift;
  my $yday = shift;

  my @days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
  my $month = -1;
  my $mday = -1;

  # Sanity check for the supplied year
  if ( $year < 1900 || $year > 3000 ) {
    print "doy2md(): year ($year) is out of range\n";
    return;
  }

  # Test for leap year
  my $leap = ( (($year%4 == 0) && ($year%100 != 0)) || ($year%400 == 0) ) ? 1 : 0;

  # Add a day to February if leap year
  if ( $leap ) {
    $days[1]++;
  }

  if ( $yday > 365+$leap || $yday <= 0 ) {
    print "doy2md(): day-of-year ($yday) is out of range\n";
    return;
  }

  for ( my $idx=0; $idx < 12; $idx++ ) {
    $yday -= $days[$idx];

    if ( $yday <= 0 ) {
      $month = $idx + 1;
      $mday = $days[$idx] + $yday;
      last;
    }
  }

  return ($month, $mday);
}  # End of doy2md()


############################################################################
# md2doy:
#
# Compute the day-of-year from a year, month and day-of-month.
#
# Year is expected to be in the range 1900-3000, month is expected to
# be in the range 1-12, mday is expected to be in the range 1-31 and
# jday will be in the range 1-366
#
# Returns 0 on success and -1 on error.
############################################################################
sub md2doy { # md2doy (year, month, mday)
  my $year = shift;
  my $month = shift;
  my $mday = shift;

  my @days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

  # Sanity check for the supplied parameters */
  if ( $year < 1900 || $year > 3000 ) {
    print "md2doy(): year ($year) is out of range\n";
    return;
  }
  if ( $month < 1 || $month > 12 ) {
    print "md2doy(): month ($month) is out of range\n";
    return;
  }
  if ( $mday < 1 || $mday > 31 ) {
    print "md2doy(): day-of-month ($mday) is out of range\n";
    return;
  }

  # Test for leap year
  my $leap = ( (($year%4 == 0) && ($year%100 != 0)) || ($year%400 == 0) ) ? 1 : 0;

  # Add a day to February if leap year
  if ( $leap ) {
    $days[1]++;
  }

  # Check that the day-of-month jives with specified month
  if ( $mday > $days[$month-1] ) {
    print "md2doy(): day-of-month ($mday) is out of range for month $month\n";
    return;
  }

  $month--;

  my $yday = 0;

  for ( my $idx=0; $idx < 12; $idx++ ) {
    if ( $idx == $month ) {
      $yday += $mday;
      last;
    }

    $yday += $days[$idx];
  }

  return $yday;
}  # End of md2doy()

#return 1;
