#!/usr/bin/perl
#
# ParseMetadata
#
# Parsed StationXML.
#
# Installation of the XML::SAX::ExpatXS module will significantly
# speed up the parsing of metadata results returned as XML.
#
# Data output
#
# A line will be written to the file for each channel epoch and will
# contain:
# "net,sta,loc,chan,lat,lon,elev,depth,azimuth,SACdip,instrument,scale,scalefreq,scaleunits,samplerate,start,end"
#
# The dip field in this output will be converted from the SEED to SAC
# convention by adding 90.  This metadata file can be used directly
# with mseed2sac or tracedsp to create SAC files including basic
# metadata.
#
#
# ## Change history ##
#
# 2011.020:
#  - Initial version
#
# Author: Chad Trabant, IRIS Data Managment Center

use strict;
use File::Basename;
use Getopt::Long;
use Time::HiRes;

my $version  = "2011.020";

my $usage      = undef;
my $verbose    = undef;
my $outfile    = undef;

# Parse command line arguments
Getopt::Long::Configure ("bundling_override");
my $getoptsret = GetOptions ( 'help|usage|h'   => \$usage,
                              'verbose|v+'     => \$verbose,
			      'outfile|o=s'    => \$outfile,
			    );

if ( ! $getoptsret || $usage || $#ARGV != 0 ) {
  my $script = basename($0);
  print "$script: Parse StationXML metadata ($version)\n\n";
  print "Usage: $script [options] StationXMLfile\n\n";
  print " Options:\n";
  print " -v                Increase verbosity, may be specified multiple times\n";
  print " -o outfile        Write basic metadata to specified file instead of printing\n";
  print "\n";
  exit 1;
}

die "Cannot find input file $ARGV[0]\n" if ( ! -f $ARGV[0] );

# An array to hold channel list and metadata
my @metadata = ();

&ParseMetaData($ARGV[0]);

# Write to either specified output file or stdout
my $metafile = ( $outfile ) ? $outfile : "-";

# Write metadata to file
if ( $metafile ) {
  if ( scalar @metadata <= 0 ) {
    printf STDERR "No metdata available\n", scalar @metadata;
  }
  else {
    printf STDERR "Writing metadata (%d channel epochs) file\n", scalar @metadata if ( $verbose );

    open (META, ">$metafile") || die "Cannot open metadata file '$metafile': $!\n";

    # Print header line
    print META "#net,sta,loc,chan,lat,lon,elev,depth,azimuth,SACdip,instrument,scale,scalefreq,scaleunits,samplerate,start,end\n";

    foreach my $channel ( sort @metadata ) {
      my ($net,$sta,$loc,$chan,$start,$end,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$samplerate,$sens,$sensfreq,$sensunit) =
	split (/,/, $channel);

      # Convert inclination/dip to SAC convention
      $dip += 90;

      $sensfreq = sprintf ("%0g", $sensfreq);
      $samplerate = sprintf ("%0g", $samplerate);

      print META "$net,$sta,$loc,$chan,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$sens,$sensfreq,$sensunit,$samplerate,$start,$end\n";
    }

    close META;
  }
}

print STDERR "DONE\n";
## End of main


######################################################################
# ParseMetaData:
#
# Parse StationXML metadata from specified file.
#
# Resulting metadata is placed in the global @metadata array with each
# entry taking the following form:
#   "net,sta,loc,chan,start,end,lat,lon,elev,depth,azimuth,dip,instrument,samplerate,sensitivity,sensfreq,sensunits"
#
######################################################################
sub ParseMetaData {
  my $xmlfile = shift;

  my $ftime = Time::HiRes::time;

  # Slurp the StationXML into a variable
  open (IN, "<$xmlfile") || die "Cannot open input file: '$xmlfile'\n";
  my $metadataxml = do { local $/, <IN> };
  close IN;

  my $datasize = (-s "$xmlfile");

  # Create stream oriented XML parser instance
  use XML::SAX;
  my $parser = new XML::SAX::ParserFactory->parser( Handler => MDSHandler->new );

  my $totalepochs = 0;

  my $ptime = Time::HiRes::time;

  print STDERR "Parsing XML metadata... " if ( $verbose );

  # Parse XML metadata
  $parser->parse_string ($metadataxml);

  printf STDERR "Done (%.1f seconds)\n", Time::HiRes::time - $ptime if ( $verbose );

  my $duration = Time::HiRes::time - $ftime;
  my $rate = $datasize/(($duration)?$duration:0.000001);
  printf (STDERR "Parsed %s of metadata for $totalepochs channel epochs in %.1f seconds (%s/s)\n",
	  sizestring($datasize), $duration, sizestring($rate));

  ## End of this routine, below is the XML parsing handler used above

  ## Beginning of SAX MDSHandler, event-based streaming XML parsing
  package MDSHandler;
  use base qw(XML::SAX::Base);
  use HTTP::Date;

  my $inepoch = 0;
  my $instart = 0;
  my $inend = 0;
  my $inlat = 0;
  my $inlat = 0;
  my $inlon = 0;
  my $inelevation = 0;
  my $indepth = 0;
  my $inazimuth = 0;
  my $indip = 0;
  my $insamplerate = 0;
  my $inequiptype = 0;

  my $intotalsens = 0;
  my $insensvalue = 0;
  my $ingainunits = 0;
  my $infrequency = 0;

  my ($net,$sta,$loc,$chan,$start,$end,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$samplerate,$sens,$sensfreq,$sensunit) = (undef) x 17;

  sub start_element {
    my ($self,$element) = @_;

    if ( $element->{Name} eq "Station" ) {
      ($net,$sta,$loc,$chan,$start,$end,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$samplerate,$sens,$sensfreq,$sensunit) = (undef) x 17;

      $net = $element->{Attributes}->{'{}net_code'}->{Value};
      $sta = $element->{Attributes}->{'{}sta_code'}->{Value};
    }

    elsif ( $element->{Name} eq "Channel" ) {
      $loc = $element->{Attributes}->{'{}loc_code'}->{Value};
      $chan = $element->{Attributes}->{'{}chan_code'}->{Value};
    }

    elsif ( $element->{Name} eq "Epoch" ) {
      $inepoch = 1;
    }

    if ( $inepoch ) {
      if ( $element->{Name} eq "StartDate" ) { $instart = 1; }
      elsif ( $element->{Name} eq "EndDate" ) { $inend = 1; }
      elsif ( $element->{Name} eq "Lat" ) { $inlat = 1; }
      elsif ( $element->{Name} eq "Lon" ) { $inlon = 1; }
      elsif ( $element->{Name} eq "Elevation" ) { $inelevation = 1; }
      elsif ( $element->{Name} eq "Depth" ) { $indepth = 1; }
      elsif ( $element->{Name} eq "Azimuth" ) { $inazimuth = 1; }
      elsif ( $element->{Name} eq "Dip" ) { $indip = 1; }
      elsif ( $element->{Name} eq "SampleRate" ) { $insamplerate = 1; }

      elsif ( $element->{Name} eq "EquipType" ) { $inequiptype = 1; }

      elsif ( $element->{Name} eq "Response" ) {
	my $stage = $element->{Attributes}->{'{}stage'}->{Value};
	$intotalsens = 1 if ( $stage eq "0" );
      }
    }

    if ( $intotalsens ) {
      if ( $element->{Name} eq "SensitivityValue" ) { $insensvalue = 1; }
      elsif ( $element->{Name} eq "GainUnits" ) { $ingainunits = 1; }
      elsif (  $element->{Name} eq "Frequency" ) { $infrequency = 1; }
    }
  }

  sub end_element {
    my ($self,$element) = @_;

    if ( $element->{Name} eq "Station" ) {
      ($net,$sta) = (undef) x 2;
    }

    elsif ( $element->{Name} eq "Channel" ) {
      ($loc,$chan) = (undef) x 2;
    }

    elsif ( $element->{Name} eq "Epoch" ) {
      # Track epoch count
      $totalepochs++;

      # Translate metadata location ID to "--" if it's spaces
      my $dloc = ( $loc eq "  " ) ? "--" : $loc;

      # Translate commas in metadata instrument name to semi-colons
      $instrument =~ s/,/;/g;

      # Cleanup start and end strings
      ($start) = $start =~ /^(\d{4,4}[-\/,:]\d{1,2}[-\/,:]\d{1,2}[-\/,:T]\d{1,2}[-\/,:]\d{1,2}[-\/,:]\d{1,2}).*/;
      ($end) = $end =~ /^(\d{4,4}[-\/,:]\d{1,2}[-\/,:]\d{1,2}[-\/,:T]\d{1,2}[-\/,:]\d{1,2}[-\/,:]\d{1,2}).*/;

      # Push channel epoch metadata into storage array
      push (@metadata, "$net,$sta,$dloc,$chan,$start,$end,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$samplerate,$sens,$sensfreq,$sensunit");

      # Reset Epoch level fields
      ($start,$end,$lat,$lon,$elev,$depth,$azimuth,$dip,$instrument,$samplerate,$sens,$sensfreq,$sensunit) = (undef) x 13;
      $inepoch = 0;
    }

    if ( $inepoch ) {
      if ( $element->{Name} eq "StartDate" ) { $instart = 0; }
      elsif ( $element->{Name} eq "EndDate" ) { $inend = 0; }
      elsif ( $element->{Name} eq "Lat" ) { $inlat = 0; }
      elsif ( $element->{Name} eq "Lon" ) { $inlon = 0; }
      elsif ( $element->{Name} eq "Elevation" ) { $inelevation = 0; }
      elsif ( $element->{Name} eq "Depth" ) { $indepth = 0; }
      elsif ( $element->{Name} eq "Azimuth" ) { $inazimuth = 0; }
      elsif ( $element->{Name} eq "Dip" ) { $indip = 0; }
      elsif ( $element->{Name} eq "SampleRate" ) { $insamplerate = 0; }

      elsif ( $element->{Name} eq "EquipType" ) { $inequiptype = 0; }

      elsif ( $element->{Name} eq "Response" ) { $intotalsens = 0; }
    }

    if ( $intotalsens ) {
      if ( $element->{Name} eq "SensitivityValue" ) { $insensvalue = 0; }
      elsif ( $element->{Name} eq "GainUnits" ) { $ingainunits = 0; }
      elsif ( $element->{Name} eq "Frequency" ) { $infrequency = 0; }
    }
  }

  sub characters {
    my ($self,$element) = @_;

    if ( $element->{Data} ) {
      if ( $instart ) { $start .= $element->{Data}; }
      elsif ( $inend ) { $end .= $element->{Data}; }
      elsif ( $inlat ) { $lat .= $element->{Data}; }
      elsif ( $inlon ) { $lon .= $element->{Data}; }
      elsif ( $inelevation ) { $elev .= $element->{Data}; }
      elsif ( $indepth ) { $depth .= $element->{Data}; }
      elsif ( $inazimuth ) { $azimuth .= $element->{Data}; }
      elsif ( $indip ) { $dip .= $element->{Data}; }
      elsif ( $insamplerate ) { $samplerate .= $element->{Data}; }

      elsif ( $inequiptype ) { $instrument .= $element->{Data}; }

      elsif ( $insensvalue ) { $sens .= $element->{Data}; }
      elsif ( $ingainunits ) { $sensunit .= $element->{Data}; }
      elsif ( $infrequency ) { $sensfreq .= $element->{Data}; }
    }
  } # End of SAX MDSHandler
} # End of FetchMetaData()


######################################################################
# sizestring (bytes):
#
# Return a clean size string for a given byte count.
######################################################################
sub sizestring { # sizestring (bytes)
  my $bytes = shift;

  if ( $bytes < 1000 ) {
    return sprintf "%d Bytes", $bytes;
  }
  elsif ( ($bytes / 1024) < 1000 ) {
    return sprintf "%.1f KB", $bytes / 1024;
  }
  elsif ( ($bytes / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f MB", $bytes / 1024 / 1024;
  }
  elsif ( ($bytes / 1024 / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f GB", $bytes / 1024 / 1024 / 1024;
  }
  elsif ( ($bytes / 1024 / 1024 / 1024 / 1024) < 1000 ) {
    return sprintf "%.1f TB", $bytes / 1024 / 1024 / 1024 / 1024;
  }
  else {
    return "";
  }
} # End of sizestring()
